#!/bin/sh
set -e

orig_dir=$(pwd -P)
mkdir -p "${CHECKOUT_PATH}"
checkout_abs=$(cd "${CHECKOUT_PATH}" && pwd -P)
git_dir_path="${checkout_abs%/}/.git"

case "$git_dir_path" in
  "${orig_dir}")
    rel_path="."
    ;;
  "${orig_dir}/"*)
    rel_path="${git_dir_path#"${orig_dir}/"}"
    ;;
  *)
    rel_path="$git_dir_path"
    ;;
esac

printf '%s\n' "$rel_path" > "$RWX_VALUES/git-dir-path"
cd "${CHECKOUT_PATH}"

if [ ! -d .git ]; then
  git init -b main
  git remote add origin "${CHECKOUT_REPOSITORY}"
fi

if [ -n "${CREDENTIAL_HELPER}" ]; then
  git config --local credential.helper "${CREDENTIAL_HELPER}"
fi

# Avoid background maintenance rewriting packfiles in incremental tool-cache runs.
git config --local maintenance.auto false
git config --local gc.auto 0

if [ "${FETCH_FULL_DEPTH}" = "true" ] || [ "${PRESERVE_GIT_DIR}" = "true" ]; then
  git fetch --no-auto-gc origin "${CHECKOUT_REF}"
else
  git fetch --no-auto-gc --depth=1 origin "${RESOLVED_SHA}"
fi

if [ "${FETCH_FULL_DEPTH}" = "true" ] || [ "${PRESERVE_GIT_DIR}" = "true" ]; then
  git checkout "${CHECKOUT_REF}"
  git reset --hard "${RESOLVED_SHA}"
else
  git checkout FETCH_HEAD
fi

# Remove untracked files that may remain from incremental cache
git clean -fd

commit_sha=$(git rev-parse HEAD | tr -d '\n')
echo "Checked out git repository at ${commit_sha}"

if [ "${SUBMODULES}" = "true" ] && [ -f .gitmodules ]; then
  if [ "${CREDENTIAL_HELPER}" != "" ]; then
    git config --global credential.helper "${CREDENTIAL_HELPER}"
  fi

  git submodule sync --recursive
  git submodule update --init --recursive

  if [ "${CREDENTIAL_HELPER}" != "" ]; then
    git config --global --unset credential.helper
  fi

  echo "Submodules initialized and updated"
fi

if [ "${LFS}" = "true" ]; then
  LFS_FILES=$(git-lfs ls-files -n)
  if [ "${LFS_FILES}" != "" ]; then
    printf '%s\n' "$LFS_FILES" > "$RWX_VALUES/lfs-files"
    FILTER_PATH_PREFIX="${CHECKOUT_PATH%/}/"
    FILTER_LINES=$(printf '%s\n' "$LFS_FILES" | jq -c --raw-input --slurp --arg prefix "$FILTER_PATH_PREFIX" 'split("\n") | map(select(. != "") | $prefix + .)')

    LFS_ENDPOINT=$(git-lfs env | grep "Endpoint=" | awk -F'[ =]' '{print $2}')
    cat << EOF > "$RWX_DYNAMIC_TASKS/lfs.yml"
- key: lfs-files
  use: cleanup-git-dir
  run: |
    cd "\${CHECKOUT_PATH}"

    DOWNLOAD_HEADERS="-H 'Accept: application/vnd.git-lfs+json'"
    DOWNLOAD_HEADERS="\$DOWNLOAD_HEADERS -H 'Content-Type: application/json'"

    if [ -n "\$GIT_SSH_KEY" ]; then
      SSH_PART=\$(printf '%s\n' "\$CHECKOUT_REPOSITORY" | sed 's/:.*//')
      REPO_PART=\$(printf '%s\n' "\$CHECKOUT_REPOSITORY" | sed 's/.*://')

      SSH_CREDENTIALS=\$(git-ssh-command "\$SSH_PART" git-lfs-authenticate "\$REPO_PART" download)
      DYNAMIC_HEADERS=\$(printf '%s\n' "\$SSH_CREDENTIALS" | jq -r '.header | to_entries | .[] | "\\(.key): \\(.value)"')
      while IFS= read -r header; do
        [ -z "\$header" ] && continue
        DOWNLOAD_HEADERS="\$DOWNLOAD_HEADERS -H '\$header'"
      done <<RWX_LFS_HEADERS
    \$DYNAMIC_HEADERS
    RWX_LFS_HEADERS
    else
      DOWNLOAD_HEADERS="\$DOWNLOAD_HEADERS -H 'Authorization: Bearer \$GITHUB_TOKEN'"
    fi

    while IFS= read -r file; do
      [ -z "\$file" ] && continue
      while IFS= read -r line; do
        case "\$line" in
          version*) VERSION=\$(printf '%s\n' "\$line" | awk '{print \$2}') ;;
          oid*) SHA256=\$(printf '%s\n' "\$line" | awk '{print \$2}' | cut -d ':' -f 2) ;;
          size*) SIZE=\$(printf '%s\n' "\$line" | awk '{print \$2}') ;;
        esac
      done < "\$file"

      CURL_COMMAND="curl -X POST \$DOWNLOAD_HEADERS"
      URL="$LFS_ENDPOINT/objects/batch"
      DATA="{\\"operation\\": \\"download\\", \\"transfer\\": [\\"basic\\"], \\"objects\\": [{\\"oid\\": \\"\$SHA256\\", \\"size\\": \$SIZE}]}"
      CURL_COMMAND="\$CURL_COMMAND -d '\$DATA' \$URL"

      RESPONSE=\$(eval "\$CURL_COMMAND")

      # Check if the response contains an error
      ERROR_MESSAGE=\$(printf '%s\n' "\$RESPONSE" | jq -r '.objects[0].error.message // empty')
      if [ -n "\$ERROR_MESSAGE" ]; then
        echo "Error downloading LFS file \$file: \$ERROR_MESSAGE"
        echo "Hint: Did you forget to push the LFS file(s)?"
        exit 1
      fi

      DOWNLOAD_URL=\$(printf '%s\n' "\$RESPONSE" | jq -r '.objects[0].actions.download.href')

      if [ "\$DOWNLOAD_URL" = "null" ] || [ -z "\$DOWNLOAD_URL" ]; then
        echo "Error: Unable to get download URL for LFS file \$file"
        echo "Response: \$RESPONSE"
        exit 1
      fi

      curl -o "\$file" "\$DOWNLOAD_URL"
    done <<RWX_LFS_FILES
    \$LFS_FILES
    RWX_LFS_FILES
  env:
    CHECKOUT_REPOSITORY: \${{ params.repository }}
    GIT_SSH_KEY:
      value: \${{ params.ssh-key }}
      cache-key: excluded
    GITHUB_TOKEN:
      value: \${{ params.github-token }}
      cache-key: excluded
    LFS_FILES: \${{ tasks.git-clone.values.lfs-files }}
    CHECKOUT_PATH: \${{ params.path }}
    PRESERVE_GIT_DIR: \${{ params.preserve-git-dir }}
  filter: ${FILTER_LINES}
EOF
      if [ "${PRESERVE_GIT_DIR}" = "true" ]; then
        cat << EOF > "$RWX_DYNAMIC_TASKS/lfs-cleanup.yml"
- key: lfs-cleanup
  use: lfs-files
  run: git add -Av
EOF
    fi
  fi
fi

# Set metadata
printf '%s' "${CHECKOUT_REPOSITORY}" >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_REPOSITORY_URL"
printf '%s' "${CHECKOUT_REPOSITORY}" | tr ':' '/' | rev | cut -d '/' -f1,2 | rev | sed 's/\.git$//' >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_REPOSITORY_NAME"

commit_message=$(git log -n 1 --pretty=format:%B)
printf '%s' "${commit_message}" >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_COMMIT_MESSAGE"
printf '%s' "${commit_message}" | head -n 1 | tr -d '\n' >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_COMMIT_SUMMARY"

committer_name=$(git log -n 1 --pretty=format:%an)
printf '%s' "${committer_name}" >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_COMMITTER_NAME"

committer_email=$(git log -n 1 --pretty=format:%ae)
printf '%s' "${committer_email}" >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_COMMITTER_EMAIL"

unresolved_ref=""
if [ -n "${META_REF}" ]; then
  unresolved_ref="${META_REF}"
elif [ "${CHECKOUT_REF}" = "${commit_sha}" ]; then
  if ! ls_remote_output=$(git ls-remote --heads --tags origin 2>&1); then
    error_file=$(mktemp "$RWX_ERRORS/error-XXXXXX")
    cat << EOF > "$error_file"
Failed to query git remote for ref resolution. The git remote operation failed.
EOF
    exit 1
  fi
  if ! refs_with_sha_at_head=$(printf '%s\n' "$ls_remote_output" | awk "\$1 ~ /^${commit_sha}/" | awk '{ print $2; }'); then
    refs_with_sha_at_head=""
  fi
  unresolved_ref=$(printf '%s\n' "$refs_with_sha_at_head" | head -n 1 | tr -d '\n')
else
  if ! ls_remote_output=$(git ls-remote --heads --tags origin 2>&1); then
    error_file=$(mktemp "$RWX_ERRORS/error-XXXXXX")
    cat << EOF > "$error_file"
Failed to query git remote for ref resolution. The git remote operation failed.
EOF
    exit 1
  fi
  if ! refs_matching_provided_ref=$(printf '%s\n' "$ls_remote_output" | grep "refs/heads/${CHECKOUT_REF}\|refs/tags/${CHECKOUT_REF}\|${CHECKOUT_REF}" | awk '{ print $2; }'); then
    refs_matching_provided_ref=""
  fi
  unresolved_ref=$(printf '%s\n' "$refs_matching_provided_ref" | head -n 1 | tr -d '\n')
fi

if [ -z "${unresolved_ref}" ]; then
  unresolved_ref="${CHECKOUT_REF}"
fi

printf '%s' "${commit_sha}" >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_COMMIT_SHA"
printf '%s' "${unresolved_ref}" >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_REF"
printf '%s' "${unresolved_ref}" | sed -E 's|refs/[^/]+/||' >> "$RWX_CACHE_KEY_EXCLUDED_ENV/RWX_GIT_REF_NAME"

if [ "${PRESERVE_GIT_DIR}" = "true" ] && [ -n "$GITHUB_TOKEN" ]; then
  git config credential.helper '!sh -c "echo username=x-access-token && echo password=${GITHUB_TOKEN}"'

  QUERY="query { viewer { databaseId login } }"
  ACCESS_TOKEN_DATA=$(curl \
    -fsSL \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
    -X POST \
    -d "{ \"query\": \"${QUERY}\"}" \
    https://api.github.com/graphql \
  )

  GIT_USERNAME=$(printf '%s\n' "$ACCESS_TOKEN_DATA" | jq -r '.data.viewer.login')
  ACCESS_TOKEN_ID=$(printf '%s\n' "$ACCESS_TOKEN_DATA" | jq -r '.data.viewer.databaseId')
  GIT_EMAIL="${ACCESS_TOKEN_ID}+${GIT_USERNAME}@users.noreply.github.com"

  git config user.email "$GIT_EMAIL"
  git config user.name "$GIT_USERNAME"
fi
