#!/bin/sh
set -e

if [ "${CHECKOUT_REF}" = "HEAD" ]; then
  echo "Cloning from HEAD is ambiguous. If you want to clone from the HEAD of a particular branch, pass in the name of that branch as the ref instead." | tee "$RWX_ERRORS/error-head" >&2
  exit 1
fi

CREDENTIAL_ARG=""
if [ "${CREDENTIAL_HELPER}" != "" ]; then
  CREDENTIAL_ARG="-c credential.helper='${CREDENTIAL_HELPER}'"
fi
COMMAND="git $CREDENTIAL_ARG ls-remote \"${CHECKOUT_REPOSITORY}\" \"${CHECKOUT_REF}\""
LS_REMOTE_OUTPUT=$(eval "$COMMAND")
LS_REMOTE_LINE_COUNT=$(echo "$LS_REMOTE_OUTPUT" | wc -l)

if [ "$LS_REMOTE_LINE_COUNT" -gt 1 ]; then
  {
    echo "ref '${CHECKOUT_REF}' is ambiguous. git ls-remote returned multiple matches:"
    echo "$LS_REMOTE_OUTPUT"
    echo ""
    echo "Please specify a more specific ref (e.g., 'refs/heads/${CHECKOUT_REF}' for a branch or 'refs/tags/${CHECKOUT_REF}' for a tag)."
  } | tee "$RWX_ERRORS/error-ambiguous-ref" >&2
  exit 1
fi

RESOLVED_SHA=$(echo "$LS_REMOTE_OUTPUT" | awk '{print $1}')
if [ "$RESOLVED_SHA" = "" ]; then
  RESOLVED_SHA="${CHECKOUT_REF}"
fi
echo "Latest SHA for ${CHECKOUT_REF}: ${RESOLVED_SHA}"
printf '%s' "${RESOLVED_SHA}" >> "$RWX_VALUES/sha"

mkdir -p "${CHECKOUT_PATH}"
cd "${CHECKOUT_PATH}"
CHECKOUT_PATH="$(pwd -P)"
params="${CHECKOUT_REPOSITORY}-${CHECKOUT_PATH}-${LFS}-${PRESERVE_GIT_DIR}-${FETCH_FULL_DEPTH}-${SUBMODULES}-$(id -u)"
params_hash="$(echo "${params}" | sha256sum | cut -d ' ' -f 1)"
printf '%s' "${TOOL_CACHE_KEY_PREFIX}-${params_hash}" > "$RWX_VALUES/tool-cache-key"

if [ ! -d "$PATCHES_DIR" ]; then
  echo ""
  echo "No patches to apply"
  exit 0
fi

for file in "$PATCHES_DIR"/*; do
  echo ""
  filename=$(basename "$file")
  if [ -d "$file" ]; then
    echo "Patch file $filename is a directory. Skipping..."
  elif [ -f "$file" ]; then
    if [ "$filename" = "$RESOLVED_SHA" ]; then
      echo "Patch file $filename matches the resolved sha."
      echo "Generating dynamic git-patch task..."

      cat << EOF > "$RWX_DYNAMIC_TASKS/patch.yml"
- key: git-patch
  use: cleanup-git-dir
  run: |
    # Apply the patch
    echo "Applying patch file \${PATCH_FILE}..."
    cd "\${CHECKOUT_PATH}"

    git apply --stat --summary "\${PATCH_FILE}"
    git apply "\${PATCH_FILE}"

    # Export env vars
    PATCH_GIT_COMMIT_SHA="\${RWX_GIT_COMMIT_SHA}+patch"
    printf '%s' "\${PATCH_GIT_COMMIT_SHA}" >> "\${RWX_CACHE_KEY_EXCLUDED_ENV}/MINT_GIT_COMMIT_SHA"
    printf '%s' "\${PATCH_GIT_COMMIT_SHA}" >> "\${RWX_CACHE_KEY_EXCLUDED_ENV}/RWX_GIT_COMMIT_SHA"

    # Upload an artifact
    cp "\${PATCH_FILE}" "\$RWX_ARTIFACTS/\$(basename "\$PATCH_FILE").patch"
  env:
    CHECKOUT_PATH: \${{ params.path }}
    PATCH_FILE: \${{ run.dir }}/.patches/$filename
  filter:
    \${{ run.dir }}: [.patches/$filename]
EOF
    else
      echo "Patch file $filename does not match the resolved sha $RESOLVED_SHA. Skipping..."
    fi
  fi
done
